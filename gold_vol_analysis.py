# -*- coding: utf-8 -*-
"""gold_vol_analysis.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f1L2MRumathS9dx83XIp9B8jnCyEVVaG
"""

pip install yfinance

pip install arch

!pip install plotly

import pandas as pd
import numpy as np
import yfinance as yf
from arch import arch_model
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import warnings
import plotly.graph_objects as go

TICKER_ASSET = "GLD"
TICKER_VIX = "^GVZ"

# Note: GVZ only exists since 2008. Setting the date to 1990 will break the VIX comparison.
START_DATE = "2010-01-01"
SPLIT_DATE = "2023-01-01" # Shifted the split to ensure sufficient training data

ROLL_DAYS = 30
TRADING_DAYS = 252

print(f"Analyzing Asset: {TICKER_ASSET} vs Volatility Index: {TICKER_VIX}")

# 1. ROBUST DOWNLOAD
data = yf.download([TICKER_ASSET, TICKER_VIX], start=START_DATE, progress=False)['Close']
data.columns = ['Asset', 'VIX']

# 2. TIMEZONE FIX
# Remove timezone info to prevent date-matching conflicts
if data.index.tz is not None:
    data.index = data.index.tz_localize(None)

# 3. DATA CLEANING
# Gold and VIX may have different closing times or holidays.
# This aligns the datasets by dropping rows where either value is missing.
data.dropna(inplace=True)

# Data verification
print(f"Valid data points: {len(data)} rows.")
if len(data) < 252:
    print("WARNING: Insufficient data. Consider changing Tickers or Dates.")

# 4. PRELIMINARY CALCULATIONS
data['Log_Ret'] = 100 * np.log(data['Asset'] / data['Asset'].shift(1))
data['Realized_Vol'] = data['Log_Ret'].rolling(window=ROLL_DAYS).std() * np.sqrt(TRADING_DAYS)
data.dropna(inplace=True)

# 1. SPLIT DATA INTO IN-SAMPLE (TRAIN) AND OUT-OF-SAMPLE (TEST)
mask_train = data.index < SPLIT_DATE
train_data = data.loc[mask_train, 'Log_Ret']

# 2. DEFINE AND FIT GARCH(1,1) ON TRAINING DATA ONLY
print(f"Fitting GARCH(1,1) on data before {SPLIT_DATE}...")
# Note: 'mean=Zero' is used as returns are centered around 0 in high-frequency/daily logs
model = arch_model(train_data, vol='Garch', p=1, q=1, mean='Zero', dist='Normal')
res_train = model.fit(disp='off')

# 3. OUT-OF-SAMPLE GENERATION (FIXED PARAMETERS)
# We replicate the model structure for the FULL dataset
model_all = arch_model(data['Log_Ret'], vol='Garch', p=1, q=1, mean='Zero', dist='Normal')

# We apply the parameters optimized on the training set to the entire dataset
# This computes "conditional volatility" using fixed rules to avoid look-ahead bias
res_oos = model_all.fix(res_train.params)

# 4. EXTRACT ANNUALIZED VOLATILITY
# The 'arch' package returns daily volatility. We multiply by sqrt(252) to annualize.
data['GARCH_OOS'] = res_oos.conditional_volatility * np.sqrt(TRADING_DAYS)

print("GARCH Out-of-Sample calculation complete.")

# --- STEP 1: DATA DIAGNOSIS AND REPAIR ---
print("Current columns in DataFrame:", data.columns.tolist())

# Fix 1: If 'VIX' exists but 'VIX_Close' does not, create a copy
if 'VIX' in data.columns and 'VIX_Close' not in data.columns:
    data['VIX_Close'] = data['VIX']
    print("--> 'VIX_Close' column successfully created.")

# Fix 2: GARCH Check
if 'GARCH_OOS' not in data.columns:
    print("WARNING: 'GARCH_OOS' column is missing. The model has not been calculated.")
    print("Filling with zeros to prevent plot crash (re-run the GARCH block!)")
    data['GARCH_OOS'] = 0

# --- STEP 2: PLOTLY CHART ---
fig = go.Figure()

# 1. Add VIX (Implied)
fig.add_trace(go.Scatter(
    x=data.index,
    y=data['VIX_Close'],
    mode='lines',
    name=f'Implied ({TICKER_VIX})',
    line=dict(color='#1f77b4', width=1),
    opacity=0.8
))

# 2. Add Realized Volatility
fig.add_trace(go.Scatter(
    x=data.index,
    y=data['Realized_Vol'],
    mode='lines',
    name=f'Realized ({ROLL_DAYS}d rolling)',
    line=dict(color='#ff7f0e', width=2)
))

# 3. Add GARCH Out-of-Sample
fig.add_trace(go.Scatter(
    x=data.index,
    y=data['GARCH_OOS'],
    mode='lines',
    name='GARCH(1,1) OOS',
    line=dict(color='#2ca02c', width=1.5),
    opacity=0.9
))

# Convert date to timestamp for Plotly compatibility
split_date_numeric = pd.to_datetime(SPLIT_DATE).timestamp() * 1000

fig.add_vline(
    x=split_date_numeric,
    line_width=2,
    line_dash="dash",
    line_color="grey",
    annotation_text="OOS Split"
)

# Layout settings
fig.update_layout(
    title=f"{TICKER_ASSET} vs {TICKER_VIX} â€” Volatility Analysis",
    xaxis_title="Date",
    yaxis_title="Annualized Volatility (%)",
    template="plotly_dark",
    hovermode="x unified",
    legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01)
)

fig.update_xaxes(rangeslider_visible=True)

fig.show()

# Filter only the Out-of-Sample period for evaluation
df_eval = data[data.index >= SPLIT_DATE].dropna()

def calculate_metrics(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    corr = np.corrcoef(y_true, y_pred)[0, 1]
    r2 = r2_score(y_true, y_pred)

    # Simple Linear Regression for a (bias) and b (slope)
    # y_true = a + b * y_pred
    poly = np.polyfit(y_pred, y_true, 1)
    b = poly[0]
    a = poly[1]

    # sMAPE (Symmetric Mean Absolute Percentage Error)
    smape = 100 * np.mean(2 * np.abs(y_pred - y_true) / (np.abs(y_pred) + np.abs(y_true)))

    return [mae, rmse, corr, r2, a, b, smape]

# Calculate for GARCH vs Realized
metrics_garch = calculate_metrics(df_eval['Realized_Vol'], df_eval['GARCH_OOS'])
# Calculate for VIX vs Realized
metrics_vix = calculate_metrics(df_eval['Realized_Vol'], df_eval['VIX_Close'])

# Create DataFrame similar to your screenshot
metrics_df = pd.DataFrame([metrics_garch, metrics_vix],
                          columns=['MAE', 'RMSE', 'Corr', 'R2', 'a (bias)', 'b (slope)', 'sMAPE%'],
                          index=['GARCH_OOS vs Realized', 'VIX vs Realized'])

print("\n--- Metriche (OOS) ---")
display(metrics_df.round(3))